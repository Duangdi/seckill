# 秒杀系统

## 项目地址
初步完成，还在更新中，已部署在http://47.112.146.78:9898/

## 相关技术
- Springboot
- Vue
- Mybatis
- Redis
- MySQL

## 参考资料
慕课网的免费SSM秒杀系统项目：https://www.imooc.com/learn/587  

## 具体描述
### 1.0初版
- 由于参考的是`SSM+JSP`的前后端不分离项目，鉴于`SSM+JSP`技术较为落后，本项目有所改动，使用了`Springboot+Vue`，即前后端分离，后端返回`JSON`数据，而前端使用后台的接口获取相关的`JSON`数据，并展示在前端页面中。
- 由于未系统学过前端和`vue`，前端方面是边百度边敲的，所以前端可能较为简陋。
- 为避免重复卖（一个用户多次秒杀）、超卖（库存不足仍生成订单）、超时卖（不在秒杀时间内却卖出）等情况，秒杀时用了`@Transactional`注解，即生成订单和减少库存时使用了事务，且使用行级的加锁，任意情况出问题时进行回滚。
- 通过`Redis+MySQL`的形式，让`Redis`负责读数据，`MySQL`负责写数据，减缓了秒杀高并发时`MySQL`的压力，且即使`MySQL`加锁也能读取商品信息，唯一缺点就是无法保证商品库存的即时性，但`Redis`的`Key`设置了2秒生存时间，保证读取的信息是2秒内的数据。
- 无登录功能，前端用`Cookie`保存收货地址后，直接传到后端生成订单。
- 鉴于时间原因，前端无实现订单查询功能，但已提供了后端接口，可访问：http://47.112.146.78:8086/orders/list
- 提供了一个随机生成秒杀商品的按钮，便于测试。
#### jmeter压力测试
![jmeter](https://github.com/MMMMMMMW/seckill/blob/master/image/seckill1.0.png?raw=true)

由于没有对高并发时的写数据进行优化，此时并发量只有400/s


### 2.0版
- 由于1.0版只用了Redis进行数据的读取，只缓解了MySQL的读取压力，对秒杀时写数据毫无帮助，所以需要进行优化。

#### 库存优化
1.0版本中，即使库存不足，仍然会经过`MySQL`进行减库存操作，这里可以先用`Redis`减库存操作，当库存不足时，就无需经过`MySQL`了，且秒杀结束后可以设置一个`key = end:商品Id`，库存不足后直接判断该`key`即可。

#### 重复秒杀优化
当一个用户秒杀成功或`MySQL`返回重复秒杀的结果后，设置一个`key`= `success:商品Id:用户Id`到`Redis`中，生存时间10分钟，这样，同一用户下次秒杀同一商品时，假如存在该`key`，则直接返回`重复秒杀`即可。

#### 热点数据本地一级缓存
虽然`Redis`较快，但终究是设置在其他服务器中，网络会有延迟，所以设置了本地缓存作为一级缓存。  
由于本地缓存在JVM中，所有容量较少，使用了`google.guava`，基于LRU，专门用来存储热点数据。  
我们首先访问本地一级缓存，如果不存在，再访问Redis二级缓存，还不存在才访问MySQL。

#### Jmeter压力测试
![jmeter](https://github.com/MMMMMMMW/seckill/blob/master/image/seckill2.0.png?raw=true)

经过2.0版本的优化，秒杀系统的吞吐量从400/s直接升到了2000/s，提升到了5倍

### 遇到的一些坑
- Java中的内容序列化存储在Redis中后，字符前面会加上"\x1"之类的内容，使得对Redis中整数Value加减操作会出现错误，因为例如传入Value为1，在Redis中显示的可能就是"/x2/x11"这样的非整数



