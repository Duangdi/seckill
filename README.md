# 秒杀系统

## 项目地址
初步完成，还在更新中，已部署在http://47.112.146.78:9898/

## 相关技术
- Springboot
- Vue
- Mybatis
- Redis
- MySQL


## 参考资料
慕课网的免费SSM秒杀系统项目：https://www.imooc.com/learn/587  

## 具体描述
### 1.0初版
#### 前后端分离
- 由于参考的是`SSM+JSP`的前后端不分离项目，鉴于`SSM+JSP`技术较为落后，本项目有所改动，使用了`Springboot+Vue`，即前后端分离，后端返回`JSON`数据，而前端使用后台的接口获取相关的`JSON`数据，并展示在前端页面中。
- 由于未系统学过前端和`vue`，前端方面是边百度边敲的，所以前端可能较为简陋。
#### 避免超卖、重复卖、超时卖
- 为避免重复卖（一个用户多次秒杀）、超卖（库存不足仍生成订单）、超时卖（不在秒杀时间内却卖出）等情况，秒杀时用了`@Transactional`注解，即生成订单和减少库存时使用了事务，且使用行级的加锁，任意情况出问题时进行回滚。

#### MD5接口加密
- 为了避免在秒杀前就获取后端接口，提前重复多次进行秒杀操作，使得秒杀开始的瞬间成功秒杀，秒杀接口采用了MD5加密。
- 只有在秒杀时间内，才能获取MD5加密的值，从而获取秒杀的接口，进行秒杀操作

#### 无需登录
- 无需登录和注册，用户提供手机号、姓名和收货地址便可直接下单，前端用`Cookie`保存收货地址后，直接传到后端生成订单。

#### 其他功能
- 鉴于时间原因，前端无实现订单查询功能，但已提供了后端接口，可访问：http://47.112.146.78:8086/orders/list
- 提供了一个随机生成秒杀商品的按钮，便于测试。
#### jmeter压力测试
![jmeter](https://github.com/MMMMMMMW/seckill/blob/master/image/seckill1.0.png?raw=true)

由于没有对高并发时的写数据进行优化，此时并发量只有400/s


### 2.0版
- 由于1.0版只用了Redis进行数据的读取，只缓解了MySQL的读取压力，对秒杀时写数据毫无帮助，所以需要进行优化。

#### 库存优化
- 1.0版本中，即使库存不足，仍然会经过`MySQL`进行减库存操作，导致`MySQL`负载过大。
- 这里可以先用`Redis`减库存操作，当库存不足时，就无需经过`MySQL`了，且秒杀结束后可以设置一个`key = end:商品Id`，库存不足后直接判断该`key`即可。

#### 重复秒杀优化
- 当一个用户秒杀成功或`MySQL`返回重复秒杀的结果后，设置一个`key`= `success:商品Id:用户Id`到`Redis`中，生存时间10分钟，这样，同一用户下次秒杀同一商品时，假如存在该`key`，则直接返回`重复秒杀`即可。

#### 热点数据本地一级缓存
- 虽然`Redis`较快，但终究是设置在其他服务器中，网络会有延迟，所以设置了本地缓存作为一级缓存。  
- 由于本地缓存在JVM中，所有容量较少，使用了`google.guava`，基于LRU，专门用来存储热点数据。  
- 我们首先访问本地一级缓存，如果不存在，再访问Redis二级缓存，还不存在才访问MySQL。

#### Jmeter压力测试
![jmeter](https://github.com/MMMMMMMW/seckill/blob/master/image/seckill2.0.png?raw=true)

经过2.0版本的优化，秒杀系统的吞吐量从400/s直接升到了2000/s，提升到了5倍

### 遇到的一些坑
- Java中的内容序列化存储在Redis中后，字符前面会加上"\x1"之类的内容，使得对Redis中整数Value加减操作会出现错误，因为例如传入Value为1，在Redis中显示的可能就是"/x2/x11"这样的非整数。
- 前端`vue`通过点击界面上的`填写收货信息`可以访问`http://47.112.146.78:9898/seckill/userInfo`，但手动刷新或直接访问`http://47.112.146.78:9898/seckill/userInfo`就会`404`，由于本人对前端和`vue`不熟，仅花了两天时间突击学过，暂无解决方法



